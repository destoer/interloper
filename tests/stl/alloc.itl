

func test_arena() bool
{
    buf : byte[1024];
    arena : std::Arena = std::make_arena(buf);

    vla := std::byte_arr_arena(&arena,25);

    for [@v , i] in vla
    {
        @v = cast(byte,i);
    }

    res := vla.len * vla[3];

    return res == 75;
}

func test_heap() bool
{
    std::print("before alloc:\n");
    std::heap_usage(&itl_context.heap);


    vla := std::byte_arr_heap(&itl_context.heap,25);

    std::print("after alloc:\n");
    std::heap_usage(&itl_context.heap);

    for [@v , i] in vla
    {
        @v = cast(byte,i * 2);
    }

    res := vla.len * vla[3];

    std::destroy_arr_heap_byte(&itl_context.heap,&vla);
    
    std::print("after free:\n");
    std::heap_usage(&itl_context.heap);

    // check data is also free
    return res == 150 && vla.data == NULL && vla.len == 0;
}

func test_realloc() bool
{
    vla : byte[];
    std::arr_realloc_byte(&itl_context.heap,&vla,100);

    for(i in 0 < 5)
    {
        std::arr_realloc_byte(&itl_context.heap,&vla,vla.len * 2);

        for([@v , j] in vla)
        {
            @v = cast(byte,j);
        }

        std::print("alloc round {}\n",i);
        std::heap_usage(&itl_context.heap);
    }

    res := vla.len;

    std::destroy_arr_heap_byte(&itl_context.heap,&vla);

    return res == 3200;
}



struct Block
{
    ptr: byte?;
    size: usize;
}

func check_overlap(ptr: byte?, arr: Block[]) bool
{
    for block in arr
    {
        if block.ptr < ptr && ptr < block.ptr + block.size
        {
            return true;
        }
    }

    return false;
}

func stress_heap(initial: usize) bool
{
    arr : Block[10];

    for(@block in arr)
    {
        size := 55;
        block.ptr = std::alloc_heap_panic(&itl_context.heap,1,size);
        block.size = size;
    }

    pattern : u32[?] = 
    {
        0,2,3,4,5,7,2,1,8,9,5,6,6,2,1,9,8,3,4,0
    };

    for(i in pattern)
    {
        for(@block in arr)
        {
            if(check_overlap(block.ptr,arr))
            {
                std::exit(5);
            }
        }

        if(arr[i].ptr)
        {
            std::free_heap(&itl_context.heap,&arr[i].ptr);
        }

        else
        {
            size :=  i * 128;
            arr[i].ptr = std::alloc_heap_panic(&itl_context.heap,1,size);
            arr[i].size = i;
        }
    }

    for(@block in arr)
    {
        std::free_heap(&itl_context.heap,&block.ptr);
    }

    std::heap_usage(&itl_context.heap);
    return itl_context.heap.used == initial;
}

func main() s32
{
    // Need to take this as some allocations have already run
    // inside of the STL.
    initial := itl_context.heap.used;

    pass := test_arena() && test_heap() && test_realloc() && stress_heap(initial);

    return cast(s32,pass);
}