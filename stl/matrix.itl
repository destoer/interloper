namespace std;

struct Mat4D
{
    mat: f64[4][4];
}

constant MAT4_IDENT: const Mat4D = {{
    {1.0,0.0,0.0,0.0},
    {0.0,1.0,0.0,0.0},
    {0.0,0.0,1.0,0.0},
    {0.0,0.0,0.0,1.0},
}};


func mul_vec3_mat4(v1: const Vec3F@,m1: const Mat4D@) Vec3F
{
    // Implicit w of one on input vec
    x := (v1.x * m1.mat[0][0]) + (v1.y * m1.mat[0][1]) + (v1.z * m1.mat[0][2]) + m1.mat[0][3]; 
    y := (v1.x * m1.mat[1][0]) + (v1.y * m1.mat[1][1]) + (v1.z * m1.mat[1][2]) + m1.mat[1][3]; 
    z := (v1.x * m1.mat[2][0]) + (v1.y * m1.mat[2][1]) + (v1.z * m1.mat[2][2]) + m1.mat[2][3]; 
    w := (v1.x * m1.mat[3][0]) + (v1.y * m1.mat[3][1]) + (v1.z * m1.mat[3][2]) + m1.mat[3][3]; 

    // If w is not 1.0 we have to normalize the coordinates
    if(w != 1.0)
    {
        x /= w;
        y /= w;
        z /= w;
    }

    return Vec3F {
        x,
        y,
        z
    };
}

func mul_mat4(m1: const Mat4D@,m2: const Mat4D@) Mat4D
{   
    ans: Mat4D = {?};

    constant MAT_4D_SIZE: u32 = 4;

    for r in 0 < MAT_4D_SIZE 
    {
        for c in 0 < MAT_4D_SIZE
        {
            for i in 0 < MAT_4D_SIZE
            {
                ans.mat[r][c] += m1.mat[r][i] * m2.mat[i][c];
            }
        }
    }     

    return ans;
}