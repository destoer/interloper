import <string>

namespace std;

func print_int(file: File@, v : u64, base : u32)
{
    if(base > 16 || base == 0)
    {
        crash_and_burn("invalid base in print_int: \n");
    }   

    if(v == 0)
    {
        putchar_file(file,'0');
        return;
    }

    // integer to char lut
    DIGIT_CHAR := "0123456789ABCDEF";

    buf : c8[MAX_INT_CHARS] = {?};
    digits : u32 = 0;

    while(v != 0)
    {
        digit :=  v % base;
        v = v / base;

        char : c8 = DIGIT_CHAR[digit];

        buf[digits] = char;

        digits += 1;
    }

    reverse_str(buf,digits);

    write_string_file(file, buf[:digits]);
}

func print_dec(file: File@, v : u64, sign : bool)
{
    if(sign && cast(s64,v) < 0)
    {
        v = ~v + 1;
        putchar_file(file,'-');
    }

    print_int(file,v,10);
}

func print_bin(file: File@, v : u64)
{
    write_string_file(file, "0b");
    print_int(file,v,2);  
}

func print_hex(file: File@, v : u64)
{
    write_string_file(file, "0x");
    print_int(file,v,16);
}

func print_int_arg(file: File@, any : rtti::Any, specifier: c8)
{
    v := rtti::int_from_any(any);

    switch(specifier)
    {
        case 'd':
        {
            sign := rtti::is_signed(any.type);
            print_dec(file,v,sign);
        }

        case 'b':
        {
            print_bin(file,v);
        }

        case 'x':
        {
            print_hex(file,v);
        }

        default:
        {
            sign := rtti::is_signed(any.type);
            print_dec(file,v,sign);
        }
    }
}

func putchar_file(file: File@, char : c8)
{
    write_str_raw_file(file,&char,sizeof(char));
}


func putchar(char : c8)
{
    write_str_raw_file(&stdout,&char,sizeof(char));
}

func linefeed()
{
    putchar('\n');
}

func print_float(file: File@, v : f64, spec_dp: u32)
{
    // bit cast so we can pull apart the components 
    // as we need to check for magic constants
    raw : u64;
    memcpy(&raw,&v,sizeof(v));

    sign : bool = cast(bool,raw >> 63);
    exp := (raw >> 52) & 0b1111_1111_111;
    sig := raw & ~(0b1111_1111_1111_11 << 52);

    if(exp == 0b1111_1111_111)
    {
        if(sig == 0)
        {
            if(sign)
            {
                write_string_file(file, "-inf");
            }

            else
            {
                write_string_file(file, "+inf");
            }
        }

        else
        {
            write_string_file(file, "NaN");
        }

        return;
    }


    buffer: c8[256];

    dp: u32 = 0;
    idx: u32 = 0;

    // adjust so its +ve for the below algorithm
    if(sign)
    {
        buffer[idx] = '-';
        idx += 1;
        v = -v;

        // offset dp
        dp += 1;
    }

    whole_digits: u32 = 0;
    digits: u32 = 0;

    // rescale so we have it 10^1 units
    if(v >= 1.0)
    {
        power : u32 = 0;

        while(v >= 10.0)
        {
            power += 1;
            v /= 10.0;
        }

        // if we have say 10^2 we have 100 i.e 3 whole digits
        whole_digits = power + 1;
        dp += whole_digits;
    }

    // special case '0' digit
    else
    {
        whole_digits = 1;

        buffer[idx] = '0';
        idx += 1;
        digits += 1;

        dp += 1;
        v *= 10.0;
    }

    // can print whole digits plus number of dp
    allowed_prec := whole_digits + spec_dp;

    // okay at this point we can just shift each digit out the rhs
    // until the number hits zero like any other printing algorithm
    // TODO: their are precision problems using floats to calculate this 
    while(idx < buffer.len && digits < allowed_prec)
    {
        // set dp
        if(idx == dp)
        {
            buffer[idx] = '.';
            idx += 1;
        }

        digit := cast(s32,v);

        // convert digit to char
        buffer[idx] = cast(c8,'0' + digit);
        idx += 1;
        digits += 1;

        // move in next digit
        v -= cast(f64,digit);
        v *= 10.0;
    }

    write_string_file(file, buffer[:idx]);
}

func print_builtin_arg(file: File@, arg: rtti::Any, specifier : c8)
{
    builtin := cast(rtti::BuiltinType@,arg.type);

    switch(builtin.builtin)
    {
        case rtti::builtin_type::u8_t:
        {
            print_int_arg(file,arg,specifier);
        }

        case rtti::builtin_type::u16_t:
        {
            print_int_arg(file,arg,specifier);    
        }

        case rtti::builtin_type::u32_t:
        {
            print_int_arg(file,arg,specifier);
        }

        case rtti::builtin_type::u64_t:
        {
            print_int_arg(file,arg,specifier);
        }

        case rtti::builtin_type::s8_t:
        {
            print_int_arg(file,arg,specifier);
        }

        case rtti::builtin_type::s16_t:
        {
            print_int_arg(file,arg,specifier);
        }

        case rtti::builtin_type::s32_t:
        {
            print_int_arg(file,arg,specifier);
        }

        case rtti::builtin_type::s64_t:
        {
            print_int_arg(file,arg,specifier);
        }

        case rtti::builtin_type::c8_t:
        {
            char := rtti::char_from_any(arg);
            putchar_file(file,char);
        }

        case rtti::builtin_type::byte_t:
        {
            print_int_arg(file,arg,specifier);
        }

        case rtti::builtin_type::f64_t:
        {
            float := rtti::float_from_any(arg);

            print_float(file,float,6);
        }

        case rtti::builtin_type::bool_t:
        {
            res := rtti::bool_from_any(arg);

            if(res)
            {
                write_string_file(file, "true");
            }

            else
            {
                write_string_file(file, "false");
            }
        }

        case rtti::builtin_type::null_t:
        {
            write_string_file(file, "NULL");
        }
    }
}

func print_arg(file: File@, arg : rtti::Any, specifier : c8)
{
    type := arg.type;

    switch(type.kind)
    {
        case rtti::type_class::builtin_t:
        {
            print_builtin_arg(file,arg, specifier);
        }

        case rtti::type_class::pointer_t:
        {
            v := rtti::int_from_any(arg);

            if(!v)
            {
                write_string_file(file, "NULL");
            }

            else
            {
                write_string_file(file, "0x");
                print_int(file,v,16);
            }
        }

        case rtti::type_class::array_t:
        {
            array_type := cast(const rtti::ArrayType@,type);

            if(rtti::is_string(type))
            {
                if(rtti::is_runtime_size(array_type.size))
                {
                    // vla string
                    vla := cast(rtti::Vla@,arg.data);
                    buffer: const string = {cast(c8@,vla.data),vla.len};
                    write_string_file(file, buffer);
                }

                else
                {
                    char_ptr : const c8@ = cast(const c8@,arg.data);

                    buffer: const string = {char_ptr,array_type.size};
                    write_string_file(file, buffer);
                }
            }

            else
            {
                any: rtti::Any = {cast_ref(NULL),array_type.contained_type,true};
                len: usize = 0;

   
                if(rtti::is_runtime_size(array_type.size))
                {
                    vla := cast(rtti::Vla@,arg.data);
                    any.data = vla.data;
                    len = vla.len;
                }

                else
                {
                    any.data = arg.data;
                    len = array_type.size;
                }

                write_string_file(file,"[");

                for i in 0 < len 
                {
                    print_arg(file,any,specifier);

                    if i != len - 1
                    {
                        write_string_file(file,", ");
                    }

                    any.data += array_type.sub_size;
                }

                write_string_file(file,"] ");
            }
        }

        case rtti::type_class::struct_t:
        {
            unimplemented("struct print");
        }

        case rtti::type_class::enum_t:
        {
            enum_type := cast(const rtti::EnumType@,type);
            enumeration := enum_type.enumeration;

            member_opt := rtti::find_member(enumeration,rtti::enum_idx_from_any(arg));
            if member_opt == NULL
            {
                fprint(file,"{}::{}",enumeration.name,"unknown_member");
            }

            else
            {
                member := cast_ref(member_opt);
                fprint(file,"{}::{}",enumeration.name,member.name);
            }
        }
    }
}


func fprint_args(file: File@, fmt : const string, args : const rtti::Any[])
{
    arg_count : u32 = 0;

    for(i in 0 < fmt.len)
    {
        char := fmt[i];

        if(char == '{')
        {
            if(fmt.len <= i + 1 || arg_count == args.len)
            {
                crash_and_burn("ran out of args in print()");
            }
        
            specifier := fmt[i+1];

            // default fmt
            if(specifier == '}')
            {
                print_arg(file,args[arg_count],'\0');
                arg_count += 1;
                i += 1;
            }

            // arg with specifier
            else
            {
                print_arg(file,args[arg_count],specifier);
                i += 2;
                arg_count += 1;   
            }
        }

        else
        {
            putchar_file(file, char);
        }
    }
}

#attr(format = fmt)
func fprint(file: File@,fmt: const string, args: ...)
{  
    fprint_args(file,fmt,args);
}

func print_args(fmt : const string, args : const rtti::Any[])
{
    fprint_args(&stdout,fmt,args);
}

func format_args(fmt : const string, args : const rtti::Any[]) String
{
    file := open_memory_file();
    fprint_args(&file,fmt,args);    

    string := string_from_array(&file.buffer);

    return string;
}

#attr(format = fmt)
func format(fmt: const string, args : ...) String
{
    return format_args(fmt,args);
}

func println_args(fmt : const string, args : const rtti::Any[])
{
    print_args(fmt,args);
    linefeed();
}

#attr(format = fmt)
func print(fmt: const string, args : ...)
{
    print_args(fmt,args);
}

#attr(format = fmt)
func println(fmt: const string, args : ...)
{
    print_args(fmt,args);
    linefeed();
}

func crash_and_burn_args(fmt: const string, args: const rtti::Any[])
{
    write_string("\ncrash and burn: ");
    print_args(fmt,args);

    write_string("\n");

    exit(2);
}

#attr(format = fmt)
#attr(no_return)
func crash_and_burn(fmt: const string, args: ...)
{
    crash_and_burn_args(fmt,args);
}

// TODO: add line and file info? (what mechanism should be used for this)
func unimplemented_args(fmt: const string, args: const rtti::Any[])
{
    write_string("\nunimplemented: ");
    print_args(fmt,args);
    
    write_string("\n");

    exit(2);
}

#attr(format = fmt)
#attr(no_return)
func unimplemented(fmt: const string, args: ...)
{
    unimplemented_args(fmt,args);
}