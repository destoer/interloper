// NOTE: abstracts away bottom level primitives that with the os

// TODO: make this handle multiple targets we probably want a very primtive switching mechanism
// for imports

constant SYSCALL_EXIT : u32 = 0;
constant SYSCALL_OPEN : u32 = 1;
constant SYSCALL_CLOSE : u32 = 2;
constant SYSCALL_WRITE : u32 = 3;
constant SYSCALL_READ : u32 = 4;
constant SYSCALL_ALLOC : u32 = 5;

// STD IO


import <file>

global stdout : File = open_stdout();
global stdin : File = open_stdin();

func write_str_raw(data : const c8@, len : u64)
{
    if(len == 0)
    {
        return;
    }

    else if(!data)
    {
        write_file_str(&stdout,"NULL");
    }

    else
    {
        write_file_mem(&stdout,data,len);
    }   
}

func write_string(str: const string)
{
    if(str.len == 0)
    {
        return;
    }

    else if(!str.data)
    {
        write_file_str(&stdout,"NULL");
    }

    else
    {
        write_file_str(&stdout,str);
    }
}

func read_string(str : string) string
{
    // if we are going to request input
    // flush any stdout so we get our prompt
    if(stdout.buffer_size)
    {
        flush_write(&stdout);
    }

    [str,rc] := read_file_str(&stdin,str);

    if(rc != file_read_res::success)
    {
        crash_and_burn("Failed to read from stdin!?");
    }

    return str;
}


// PROCESS

func at_exit()
{
    close_file(&stdin);
    close_file(&stdout);
}

constant FAILURE_OPEN_STDOUT : s32 = 0xf000_0001;
constant FAILURE_OPEN_STDIN : s32 = 0xf000_0002;

func exit(exit_code: s32)
{
    at_exit();
    intrin_syscall(SYSCALL_EXIT,exit_code,0,0);
}

// FILE IO

constant OS_INVALID_READ : s64 = -1;

// NOTE: this is expecting a null terminated string
func os_open(filename : const c8@, mode : u32) byte@
{
    return cast(byte@,intrin_syscall(SYSCALL_OPEN,filename,mode,0));
}

func os_close(handle : const byte@)
{
    intrin_syscall(SYSCALL_CLOSE,handle,0,0);
}

func os_write(handle : const byte@, data : const byte@, len : u64) s64
{
    return intrin_syscall(SYSCALL_WRITE,handle,data,len);
}

func os_read(handle : const byte@, data : byte@, len : u64) s64
{
    return intrin_syscall(SYSCALL_READ,handle,data,len);
}

constant INVALID_FILE_HANDLE : s64 = -1;

func is_os_handle_valid(handle : byte@) bool
{
    return cast(s64,handle) != INVALID_FILE_HANDLE;
}

// memory

constant OS_INVALID_PTR : u64 = 0; 

func os_req_mem(size : u64) byte@
{
    return cast(byte@,intrin_syscall(SYSCALL_ALLOC,size,0,0));
}