// NOTE: abstracts away bottom level primitives that with the os
// TODO: make this handle multiple targets

constant SYSCALL_EXIT : u32 = 0;
constant SYSCALL_OPEN : u32 = 1;
constant SYSCALL_CLOSE : u32 = 2;
constant SYSCALL_WRITE : u32 = 3;
constant SYSCALL_READ : u32 = 4;

// STD IO


import "file"
global stdout : File = open_stdout();
global stdin : File = open_stdin();

func write_str_raw(data : const c8@, len : u32)
{
    write_file_mem(&stdout,data,len);   
}

func write_string(str: const string)
{
    write_file_str(&stdout,str);
}

func read_string(str : string) string
{
    return read_file_str(&stdin,str);
}


// PROCESS

constant FAILURE_OPEN_STDOUT : s32 = 0xf000_0001;
constant FAILURE_OPEN_STDIN : s32 = 0xf000_0002;

func at_exit()
{
    file_close(&stdin);
    file_close(&stdout);
}

func exit(exit_code: s32)
{
    at_exit();
    intrin_syscall(SYSCALL_EXIT,exit_code,0,0);
}

// FILE IO

// NOTE: this is expecting a null terminated string
func os_open(filename : const c8@, mode : u32) byte@
{
    return cast(byte@,intrin_syscall(SYSCALL_OPEN,filename,mode,0));
}

func os_close(handle : const byte@)
{
    intrin_syscall(SYSCALL_CLOSE,handle,0,0);
}

func os_write(handle : const byte@, data : const byte@, len : u64) s64
{
    return intrin_syscall(SYSCALL_WRITE,handle,data,len);
}

func os_read(handle : const byte@, data : byte@, len : u64) s64
{
    return intrin_syscall(SYSCALL_READ,handle,data,len);
}

constant INVALID_HANDLE : u64 = 0;

func is_os_handle_valid(handle : byte@) bool
{
    return handle != cast(byte@,INVALID_HANDLE);
}