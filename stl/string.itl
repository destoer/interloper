
constant ASCII_CASE_GAP : u8 = 0x20;

// NOTE:
// will probably call the extentable one string_buffer

func to_lower(char: c8) c8
{
    if(char >= 'A' && char <= 'Z')
    {
        char -= ASCII_CASE_GAP;
    }

    return char;
}

/*
enum itl_type
{
    u8_t,
    u16_t,
    u32_t,

    s8_t,
    s16_t,
    s32_t,

    c8_t,

    byte_t,

    bool_t,

    null_t,

    pointer_t,
    array_t,
    struct_t,
    enum_t,
}
*/

// if printed in base 2, its 64 bits
constant MAX_INT_CHARS : u32 = 64;


func print_int(v : u32)
{
    if(v == 0)
    {
        write_string("0");
        return;
    }

    buf : c8[MAX_INT_CHARS];
    digits : u32 = 0;

    while(v != 0)
    {
        digit :=  v % 10;
        v  = v / 10;

        char : c8 = cast(c8,digit + '0');

        buf[digits] = char;

        digits += 1;
    }

    reverse(buf,digits);

    // TODO: this should slice
    write_buf(&buf[0],digits);
}

func format_int(any : Any)
{
    v := int_from_any(any);
    print_int(v);
}

func putchar(char : c8)
{
    write_buf(&char,sizeof(char));
}

func print_arg(arg : Any)
{
    type := arg.type;

    switch(type.type_idx)
    {
        case itl_type::u8_t:
        {
            format_int(arg);
        }

        case itl_type::u16_t:
        {
            format_int(arg);
        }

        case itl_type::u32_t:
        {
            format_int(arg);
        }

        case itl_type::s8_t:
        {
            format_int(arg);
        }

        case itl_type::s16_t:
        {
            format_int(arg);
        }

        case itl_type::s32_t:
        {
            format_int(arg);
        }

        case itl_type::c8_t:
        {
            char := char_from_any(arg);

            putchar(char);
        }

        case itl_type::byte_t:
        {
            format_int(arg);
        }

        case itl_type::bool_t:
        {
            res := bool_from_any(arg);

            if(res)
            {
                write_string("true");
            }

            else
            {
                write_string("false");
            }
        }

        case itl_type::null_t:
        {
            write_string("NULL");
        }

        case itl_type::pointer_t:
        {
            assert(false);
        }

        case itl_type::array_t:
        {
            assert(false);
        }

        case itl_type::struct_t:
        {
            assert(false);
        }

        case itl_type::enum_t:
        {
            assert(false);
        }
    }
}


//func print(fmt: const str, ...)

// TODO: switch this over to format string
// TODO: add line and file info? (what mechanism should be used for this)
func unimplemented(str: const string)
{
    write_string("unimplemented: ");
    write_string(str);
    
    exit(1);
}

func crash_and_burn(str: const string)
{
    write_string("crash and burn: ");
    write_string(str);

    exit(1);
}