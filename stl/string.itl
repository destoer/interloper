namespace std;

constant ASCII_CASE_GAP : u8 = 'a' - 'A';

func to_lower(char: c8) c8
{
    if(char >= 'A' && char <= 'Z')
    {
        char -= ASCII_CASE_GAP;
    }

    return char;
}

// if printed in base 2, its 64 bits
constant MAX_INT_CHARS : u32 = 64;


func str_copy(dst: string,src: const string) usize
{
    size := min_u64(src.len,dst.len);

    memcpy(dst.data,src.data,size);

    return size;
}

// null terminate the string after copy
func str_copy_term(dst: string,src: const string) usize
{
    size := str_copy(dst,src);

    if(size != 0)
    {
        term_pos := min_u64(size,dst.len - 1);
        dst[term_pos] = '\0';
    }

    return size;
}

func swap_c8(v1 : c8@, v2 : c8@)
{
    tmp := @v1;
    @v1 = @v2;
    @v2 = tmp;
}

func reverse_str(str : string, len : usize)
{
    for(i in 0 < len / 2)
    {
        swap_c8(&str[i],&str[len - i - 1]);
    }
}

struct Value
{
    v : u64;
    sign : bool;
};

func str_valid(str : const string) bool
{
    return str.len != 0 && str.data != NULL;
}

func is_alpha(c : c8) bool
{
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

func is_digit(c: c8) bool
{
    return c >= '0' && c <= '9';
}

// where it left off along with value
func parse_value(str : const string) [Value, const string]
{
    value : Value;
    data := str.data;
    end := str.data + str.len;

    // empty string
    if(!str_valid(str))
    {
        return value, str;
    }

    if(str[0] == '-')
    {
        data += 1;
        value.sign = true;
    }

    done := false;

    while(!done)
    {
        if(data == end)
        {
            done = true;
        }

        else
        {
            c := @data;

            v : u32 = 0;

            if(is_digit(c))
            {
                v = c - '0';
            }

            else
            {
                // letters terminate
                done  = true;
            }

            if(!done)
            {
                // accumulate digits
                value.v *= 10;
                value.v += v;

                data += 1;
            }
        }
    }

    // make twos complement if negative
    if(value.sign)
    {
        value.v = (~value.v) + 1;
    }

    used := cast(u64,data) - cast(u64,str.data);

    new: const string = {data,str.len - used};

    return value, new;
}

// NOTE: This will have many rounding errors
func string_to_double(str: const string) [result,f64]
{
    if !str
    {
        return result::err, 0.0;
    }

    start_idx := 0;

    negative := str[0] == '-';
    fractional := false;


    if(negative)
    {
        start_idx += 1;
    }

    ans := 0.0;
    fract_scale := 10.0;

    for char in str[start_idx:]
    {
        if char == '.'
        {
            // This should not occur twice
            if(fractional)
            {
                return result::err, 0.0;
            }

            fractional = true;
        }

        else
        {
            // Should only be digits here
            if(!std::is_digit(char))
            {
                return result::err, 0.0;
            }

            digit := cast(f64,char - '0');


            if(fractional)
            {
                ans += digit / fract_scale;
                fract_scale *= 10.0;
            }

            else
            {
                ans = (ans * 10.0) + digit;
            }
        }
    }

    if negative
    {
        ans = -ans;
    }

    return result::ok, ans;
}

func scan_verticies(line: const string[]) [result,std::Vec3F]
{
    ans: std::Vec3F = {?};

    [res, ans.x] := string_to_double(line[1]);
    if(res == result::err)
    {
        return res, ans;
    }

    [res, ans.y] = string_to_double(line[2]);
    if(res == result::err)
    {
        return res, ans;
    }

    [res, ans.z] = string_to_double(line[3]);
    if(res == result::err)
    {
        return res, ans;
    }

    return result::ok, ans;
}

func parse_u64(str: const string) u64
{
    [value,next] := parse_value(str);
    return value.v;
}

func parse_s64(str: const string) s64
{
    [value,next] := parse_value(str);
    return cast(s64,value.v);
}

func str_duplicate(str: const string) string
{
    data := heap_duplicate(&itl_context.heap,str.data,str.len);
    out: string = {cast(c8@,data),str.len};

    return out;
}

func find_str(str: const string, search: const string) const string
{
    blank: const string = {str.data,0};
    if search.len == 0
    {
        return blank;
    }

    for i: s32 = 0; i + search.len < str.len; i += 1
    {
        if(str[i : i + search.len] == search)
        {
            return str[i:];
        }
    }

    return blank;
}

func cmdline_args() string[]
{
    return itl_context.args;
}

func split_null_str(str: const string) Array
{
    return split_str(str,"\0");
}

func split_str(str: const string, delimitter: const string) Array
{
    array := std::make_array(sizeof_type(string));

    split_str_in(str,delimitter,&array);
    return array;
}

func split_str_in(str: const string, delimitter: const string, array: Array@)
{
    std::clear_array(array);

    done := false;

    while !done
    {
        found := find_str(str,delimitter);

        if found.len != 0
        {
            scanned := found.data - str.data;
            split := str[:scanned];
            std::push_array(array,&split);

            str = found[delimitter.len:];
        }

        else
        {
            done = true;
        }
    }

    std::push_array(array,&str);
}

struct String
{
    buf: string;
    size: usize;
}

func string_from_array(array: Array@) String
{
    str: String;
    str.size = array.size;
    str.buf = cast(string,array.buf);
    take_array(array);

    return str;
}


func reserve_string_mem(str : String@, size : usize)
{
    realloc_heap_panic(&itl_context.heap,cast(byte@@,&str.buf.data),size,sizeof_type(c8));
    str.size = size;
}

func reserve_string(str : String@, size: usize)
{
    free_size := str.size - str.buf.len;

    // we have room to just dump this in
    if(free_size >= size)
    {
        return;
    }

    else
    {   
        // reserve double
        new_capacity := (str.size + size) * 2;
        reserve_string_mem(str,new_capacity);
    }
}

func push_char(str: String@, char: c8)
{
    reserve_string(str,1);
    str.buf[str.buf.len] = char;
    str.buf.len += 1;
}

func push_char_buffer(str: String@, buffer: const string)
{
    reserve_string(str,buffer.len);
    memcpy(&str.buf[str.buf.len],buffer.data,buffer.len);
    str.buf.len += buffer.len;
}


func clear_string(str: String@)
{
    str.buf.len = 0;
}

func destroy_string(str: String@)
{
    free_heap(&itl_context.heap,cast(byte@@,&str.buf.data));
    str.size = 0;
}
