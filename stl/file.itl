
constant FILE_BLOCK_SIZE : u32 = 512;
constant FILE_DEFAULT_BUFFER_SIZE : u32 = FILE_BLOCK_SIZE * 1;

struct File
{
    flags : u32;

    // os handle
    // NOTE: inside the vm this is basically a FILE*
    handle : byte@;
    
    // for buffered io
    buf : byte[];
    
    // inside our buffer, how much data do we have?
    buffer_offset : u16;
    buffer_size : u16;
}

enum file_mode
{
    read,
    write,
}


constant FILE_FLAG_ERROR : u32 = 1 << 0;

// otherwhise a write is buffered if the buffer is not empty
constant FILE_FLAG_BUFFER_READ : u32 = 1 << 3;

func open_file(str : const string, mode : file_mode) [File,bool]
{
    file : File;    

    // null terminate the string in a stack buffer
    buf : c8[256];

    memcpy(&buf[0],&str[0],min_unsigned(str.len,buf.len - 1));
    buf[str.len] = '\0';

    file.handle = os_open(&buf[0],cast(u32,mode)); 

    if(!is_os_handle_valid(file.handle))
    {
        file.flags = file.flags | FILE_FLAG_ERROR;
        return file,true;
    }

    // TODO: we should allocate our buffer here

    return file,false;
}

func file_close(file : File@)
{
    os_close(file.handle);
    file.handle = cast(byte@,INVALID_HANDLE);
}

func write_file_str(file : File@, str : const string) s64
{
    return write_file_mem(file,str.data, str.len);
}

func write_file_mem(file : File@,buf : const byte@, len : u64) s64
{
    return os_write(file.handle,buf,len);
}

func read_file_str(file : File@, str : string) string
{
    // TODO: this should scan the buffer for a '\n'
    // if we cant find it flush the buffer

    // then keep buffering up to the length

    len := read_file_mem(file,str.data, str.len);

    // TODO: use slicing for this
    buf : c8[];

    if(len >= 0)
    {
        buf.data = str.data;
        buf.len = cast(u64,len);
    }

    return buf;
}

func read_file_mem(file : File@,buf : byte@, len : u64) s64
{
    return os_read(file.handle,buf,len);
}


func open_stdout() File
{
    fp : File;
    err : bool;

    // NOTE: for now this only works properly against linux
    [fp,err] = open_file("/dev/stdout",file_mode::write);

    if(err)
    {
        exit(FAILURE_OPEN_STDOUT);
    }

    return fp;
}

func open_stdin() File
{
    fp : File;
    err : bool;

    // NOTE: for now this only works properly against linux
    [fp,err] = open_file("/dev/stdin",file_mode::read);

    if(err)
    {
        exit(FAILURE_OPEN_STDIN);
    }

    return fp;
}