
constant FILE_BLOCK_SIZE : u32 = 512;
constant FILE_DEFAULT_BUFFER_SIZE : u32 = FILE_BLOCK_SIZE * 1;

struct File
{
    flags : u32;

    // os handle
    // NOTE: inside the vm this is basically a FILE*
    handle : byte@;
    
    // for buffered io
    buf : byte[];
    
    // inside our buffer, how much data do we have?
    buffer_offset : u64;
    buffer_size : u64;
}

enum file_mode
{
    read,
    write,
}

enum file_res
{
    eof,
    error,
    success,
}

constant FILE_FLAG_ERROR : u32 = 1 << 0;

// otherwhise a write is buffered if the buffer is not empty
constant FILE_FLAG_BUFFER_READ : u32 = 1 << 3;

func open_file(str : const string, mode : file_mode) [File,bool]
{
    file : File;    

    // null terminate the string in a stack buffer
    buf : c8[256];

    memcpy(&buf[0],&str[0],min_unsigned(str.len,buf.len - 1));
    buf[str.len] = '\0';

    file.handle = os_open(&buf[0],cast(u32,mode)); 

    if(!is_os_handle_valid(file.handle))
    {
        file.flags = file.flags | FILE_FLAG_ERROR;
        return file,true;
    }

    file.buf = byte_array_heap(&global_heap,FILE_DEFAULT_BUFFER_SIZE);

    return file,false;
}

func close_file(file : File@)
{
    os_close(file.handle);
    file.handle = cast(byte@,INVALID_FILE_HANDLE);

    // free our buffer
    free_heap(&global_heap,file.buf.data);
}

func buffer_file(file : File@) bool
{
    len := os_read(file.handle,file.buf.data,FILE_DEFAULT_BUFFER_SIZE);

    file.buffer_offset = 0;
    file.buffer_size = cast(u64,len);
    
    return len == OS_INVALID_READ;
}

func write_file_str(file : File@, str : const string) s64
{
    return write_file_mem(file,str.data, str.len);
}

func write_file_mem(file : File@,buf : const byte@, len : u64) s64
{
    return os_write(file.handle,buf,len);
}

func flush_read(file : File@, ptr : byte@, len : u64)
{
    memcpy(ptr,&file.buf[file.buffer_offset],len);

    file.buffer_offset += len;
    file.buffer_size -= len;  
}

func read_file_str(file : File@, str : string) [string, file_res]
{
    // buffer is empty rebuffer it
    if(file.buffer_size == 0)
    {
        err := buffer_file(file);

        if(err)
        {
            buf : string;
            return buf,file_res::error;
        }

        // file is completly empty!
        if(file.buffer_size == 0)
        {
            buf : string;
            return buf, file_res::eof;
        }
    }

    // attempt to find the first occurence of a '\n' 
    // now we have a buffer to work with
    remain := str.len; 
    out_offset : u64 = 0;

    while(true)
    { 
        // save size of buffer for later
        buffer_size := file.buffer_size;

        // setup pointers to scan for '\n'
        start := &file.buf[file.buffer_offset];
        ptr := start;

        // max is end of the buffer or str len, whatever is lowest
        max_read := min_unsigned(buffer_size,remain);
        end := &file.buf[file.buffer_offset + max_read];

        while(ptr != end)
        {
            // newline found
            if(@ptr == '\n')
            {
                // we have read out this char
                ptr += 1;
                remain -= 1;

                // correct the buffer offsets for the last scan
                read := cast(u64,ptr) - cast(u64,start);

                // perform the final flush to the buffer
                flush_read(file,&str[out_offset],read);

                // buf := str[0 : str.len - remain];

                // produce the final res
                buf : string;

                buf.len = str.len - remain;
                buf.data = str.data; 

                return buf,file_res::success;
            }

            // goto next char
            ptr += 1;
            remain -= 1;
        }


        // flush what we have out to file
        flush_read(file,&str[out_offset],buffer_size);
        out_offset += buffer_size;

        // rebuffer the file out
        err := buffer_file(file);

        if(err)
        {
            buf : string;
            return buf,file_res::error;
        }
    
        // there is nothing left to read we are done
        if(file.buffer_size == 0 || remain == 0)
        {
            buf : string;

            buf.len = str.len - remain;
            buf.data = str.data; 

            return buf,file_res::success;
        }
    }

    // TODO: we dont no return detection yet
    crash_and_burn("unreachable");

    // no newline hit return str
    buf : string;

    return buf,file_res::error;
}

func read_file_mem(file : File@,buf : byte@, len : u64) [s64, file_res]
{
    // enough in the buffer just pass it back out
    if(len <= file.buffer_size)
    {
        flush_read(file,buf,len);
        return len,file_res::success;
    }

    // buffer is empty rebuffer it
    if(file.buffer_size == 0)
    {
        err := buffer_file(file);

        if(err)
        {
            return -1,file_res::error;
        }

        // file is completly empty!
        if(file.buffer_size == 0)
        {
            return 0, file_res::eof;
        }
    }


    // TODO: should there be a limit where we just directly dump it into the os?
    remain := len - pending;

    // buffer file in until we are done
    while(remain != 0 && file.buffer_size != 0)
    {
        // flush out any pending data
        pending := file.buffer_size;
        flush_size := min_unsigned(remain,pending);

        flush_read(file,ptr,flush_size);

        // less byte to read
        remain -= pending;

        // buffer next ammount of file in
        if(!buffer_file(file))
        {
            return -1,file_res::error;
        }
    }

    // calc how much we actually read
    read := len - remain;

    if(file.buffer_size == 0)
    {
        return read,file_res::eof;
    }

    return read, file_res::success;
}


func open_stdout() File
{
    // NOTE: for now this only works properly against linux
    [fp,err] := open_file("/dev/stdout",file_mode::write);

    if(err)
    {
        exit(FAILURE_OPEN_STDOUT);
    }

    return fp;
}

func open_stdin() File
{
    // NOTE: for now this only works properly against linux
    [fp,err] := open_file("/dev/stdin",file_mode::read);

    if(err)
    {
        exit(FAILURE_OPEN_STDIN);
    }

    return fp;
}