
struct File
{
    flags : u32;

    // os handle
    // NOTE: inside the vm this is basically a FILE*
    handle : byte@;
    
    // for buffered io
    buf : byte[];
    pending : u32;
}

enum file_mode
{
    read,
    write,
    read_write,
}


constant FILE_FLAG_BIN : u32  = 1 << 0;
constant FILE_FLAG_STR : u32 = 1 << 1;
constant FILE_FLAG_ERROR : u32 = 1 << 2;

func open_file(str : const string, mode : file_mode, flags : u32) [File,bool]
{
    file : File;    

    file.flags = flags;

    // null terminate the string in a stack buffer
    buf : c8[256];

    memcpy(&buf[0],&str[0],min_unsigned(str.len,buf.len - 1));
    buf[str.len] = '\0';

    file.handle = os_open(&buf[0],cast(u32,mode)); 

    if(!is_os_handle_valid(file.handle))
    {
        file.flags = file.flags | FILE_FLAG_ERROR;
        return file,true;
    }

    // TODO: we should allocate our buffer here

    return file,false;
}

func file_close(file : File@)
{
    os_close(file.handle);
    file.handle = cast(byte@,INVALID_HANDLE);
}

func write_file_str(file : File@, str : const string) s64
{
    return write_file_mem(file,str.data, str.len);
}

func write_file_mem(file : File@,buf : const byte@, len : u64) s64
{
    return os_write(file.handle,buf,len);
}

func read_file_str(file : File@, str : string) s64
{
    return read_file_mem(file,str.data, str.len);
}

func read_file_mem(file : File@,buf : byte@, len : u64) s64
{
    return os_read(file.handle,buf,len);
}


func open_stdout() File
{
    fp : File;
    err : bool;

    // NOTE: for now this only works properly against linux
    [fp,err] = open_file("/dev/stdout",file_mode::write,FILE_FLAG_STR);

    if(err)
    {
        exit(FAILURE_OPEN_STDOUT);
    }

    return fp;
}

func open_stdin() File
{
    fp : File;
    err : bool;

    // NOTE: for now this only works properly against linux
    [fp,err] = open_file("/dev/stdin",file_mode::read,FILE_FLAG_STR);

    if(err)
    {
        exit(FAILURE_OPEN_STDIN);
    }

    return fp;
}