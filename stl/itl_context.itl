namespace std

struct ItlContext
{
    env_vars: std::HashTable;
    args: string[];
    heap: std::Heap;
}

global itl_context: ItlContext = {?};

func read_args()
{
    [bin, err] := read_proc_file("/proc/self/cmdline");

    if(err == result::err)
    {
        crash_and_burn("Could not read command line args");
    }

    str_buffer := cast(string,array_buffer(&bin));
    strings := split_null_str(str_buffer);
    itl_context.args = cast(string[],array_buffer(&strings));

    if(!itl_context.args.len)
    {
        crash_and_burn("Command name not passed as arg!?");
    }

    destroy_array(&bin);  
}

func read_proc_file(name: const string) [std::Array, result]
{
    [file, err] := open_file(name,std::file_mode::read,std::file_opt::open);

    buffer := std::make_array(sizeof_type(byte));

    if(err)
    {
        return buffer, result::err;
    }

    // Keep buffering the file until we hit an error or run out of stuff to read
    while(true) 
    {
        [_, res] := buffer_file_array(&buffer,&file,FILE_DEFAULT_BUFFER_SIZE);
        
        switch(res)
        {
            case file_read_res::eof:
            {
                return buffer, result::ok;
            }

            case file_read_res::success: {}

            case file_read_res::error:
            {
                return buffer, result::err;
            }
        }
    }

    return buffer,result::err;
}

func parse_keys(table: HashTable@, env: const string)
{
    for [@v, i] in env
    {
        if(@v == '=')
        {
            key := str_duplicate(env[:i]);
            value := str_duplicate(env[i+1:]);

            hash_table_add(table,&key,&value);
            return;
        }
    }

    blank: string;
    key := str_duplicate(env);

    // No key found just put the variable itself
    hash_table_add(table,&key,&blank);
}

func read_env()
{
    [bin, err] := read_proc_file("/proc/self/environ");

    if(err == result::err)
    {
        crash_and_burn("Could not read environment variables");
    }

    // Now have a list of null terminated strings.
    // Lets split them. We could use the util function but we are going
    // to do further splitting and don't want to alloc extra memory.

    var_start: u32 = 0;

    for [@v, i] in bin.buf 
    {
        char := @v;

        if(char == 0)
        {
            len := i - var_start;

            str: string = {cast(c8@,&bin.buf[var_start]),len};
            parse_keys(&itl_context.env_vars,str);

            var_start = i + 1; 
        }
    }

    destroy_array(&bin);
}

func init_itl_context()
{
    itl_context.env_vars = std::make_hash_table(sizeof_type(string),sizeof_type(string),&std::hash_string,&std::hash_cmp_str);
    read_env();
    read_args();
    log::set_log_level_from_env("ITL_LOG");
}
