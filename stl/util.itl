import <time>
namespace std;

func test_f64(v1: f64, ans: f64, name: const string)
{
    if(!float_eq(v1,ans))
    {
        println("Test {} failed: {} != {}",name,v1,ans);
        exit(1);
    }
}

func test_vec2f(v1: Vec2F, ans: Vec2F, name: const string)
{
    if(!float_eq(v1.x,ans.x) || !float_eq(v1.y,ans.y))
    {
        println("Test {} failed: ( {}, {} ) != ( {}, {} )",name,v1.x,v1.y,ans.x,ans.y);
        exit(1);
    }
}

func test_vec3f(v1: Vec3F, ans: Vec3F, name: const string)
{
    if(!float_eq(v1.x,ans.x) || !float_eq(v1.y,ans.y) || !float_eq(v1.z,ans.z))
    {
        println("Test {} failed: ( {}, {}, {} ) != ( {}, {}, {} )",name,v1.x,v1.y,v1.z,ans.x,ans.y,ans.z);
        exit(1);
    }    
}


func assert_log(cond: bool, fmt: const string, args: ...)
{
    if(!cond)
    {
        std::print("Assert failed: ");
        println_args(fmt,args);
        exit(1);
    }
}

func assert(cond : bool)
{
    if(!cond)
    {
        exit(1);
    }
}

global seed : u64 = cast(u64,time());

// basic LCG
func rand() u64
{
    seed = (6364136223846793005 * seed) + 1442695040888963407; 
    return deset_bit(seed,63);
}

func rand_range_u64(min : u64, max : u64) u64
{
    return (rand() % ((max + 1) - min)) + min;
}

func rand_range_s64(min : s64, max : s64) s64
{
    return (rand() % ((max + 1) - min)) + min;
}


func rand_range_s32(min : s32, max : s32) s32
{
    return cast(s32,rand_range_s64(min,max));
}


func rand_range_u32(min : u32, max : u32) u32
{
    return cast(u32,rand_range_u64(min,max));
}

func swap_s64(v1: s64@, v2: s64@)
{
    tmp := @v1;
    @v1 = @v2;
    @v2 = tmp;
}

func swap_f64(v1: f64@, v2: f64@)
{
    tmp := @v1;
    @v1 = @v2;
    @v2 = tmp;
}

func getenv(name: const string) const string
{
    ptr := hash_table_lookup(&std::itl_context.env_vars,&name);

    if(!ptr)
    {
        blank: string;
        return blank;
    }

    return @cast(string@,ptr);
}