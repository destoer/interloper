
// basic list impl (make this more flexible when we can)
import "alloc"

struct List
{
    start : ListNode@;
    end : ListNode@;

    arena : Arena@;
}

struct ListNode
{
    v : u32;

    next : ListNode@;
    prev : ListNode@;
}

func make_list(arena : Arena@) List
{
    list : List;
    list.arena = arena;

    return list;
}

func alloc_node(arena : Arena@, v : u32) ListNode@
{
    node : ListNode;
    node.v = v;

    ptr : ListNode@ = cast(ListNode@,allocate(arena,sizeof(node)));

    @ptr = node;

    return ptr;
}


// returns inserted node
func insert_after(list : List@, cur : ListNode@, v : u32) ListNode@
{
    node : ListNode@ = alloc_node(list.arena,v);

    if(list.start == NULL)
    {
        list.start = node;
        list.end = node;        
    }

    else
    {
        node.next = cur.next;
        node.prev = cur;
        cur.next = node;

        if(cur == list.end)
        {
            list.end = node;
        }

        else
        {
            node.next.prev = node;
        }
    }

    return node;
}

// returns inserted node
func insert_at(list : List@, cur : ListNode@, v : u32) ListNode@
{
    node : ListNode@ = alloc_node(list.arena,v);


    if(list.start == NULL)
    {
        list.start = node;
        list.end = node;
    }

    else
    {
        node.next = cur;
        node.prev = cur.prev;
        cur.prev = node;

        if(cur == list.start)
        {
            list.start = node;    
        }

        else
        {
            node.prev.next = node;
        }
    }

    return node;
}


func append(list : List@, v : u32) ListNode@
{
    return insert_after(list,list.end,v);
}

func insert_front(list : List@, v : u32) ListNode@
{
    return insert_at(list,list.end,v);
}



// return node after deleted
func remove(list : List@, node : ListNode@) ListNode@
{
    if(node == list.start)
    {
        list.start = node.next;
        
        if(list.start != NULL)
        {
            list.start.prev = NULL;

            return list.start;
        }

        return NULL;
    }

    else if(node == list.end)
    {
        list.end = node.prev;

        if(list.end != NULL)
        {
            list.end.next = NULL;
        }

        return NULL;
    }

    else
    {
        // unlink the "middle" node
        before : ListNode@ = node.prev;

        before.next = node.next;
        before.next.prev = before;

        return before.next;
    }
}