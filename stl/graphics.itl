namespace gfx;

import <os_graphics>
import <input>

struct Window
{
    size: Vec2D;
    screen: u32[];

    os_win : OSWindow;

    quit : bool = false;
    input : Input;

    start_timestamp: f64;
    end_timestamp: f64;

    target: f64;
    limit: f64;
}

struct Colour
{
    r : f64;
    g : f64;
    b : f64;
};

constant WINDOW_PREFIX :  string = "[WINDOW]: ";

func test_pattern(screen: u32[], x: u32, y: u32)
{
    for @v in screen
    {
        @v = 0x0000_ff00;
    }

    screen[((y / 2) * x) + (x / 2)] = 0x0000_00ff;
}

// called when os window is resized
func window_resized(win: Window@,x : u32, y : u32)
{
    std::log_info(WINDOW_PREFIX,"resized {} {}\n",x,y);

    win.size.x = cast(f64,x);
    win.size.y = cast(f64,y);

    // realloc our buffer
    std::arr_realloc_u32(&global_heap,&win.screen,x * y);

    // blank the screen
    test_pattern(win.screen,x,y);
}

func open_window(str : const string, x : u32, y : u32) Window
{
    win : Window;
    win.input = input::make_input();

    os_open_window(&win,str,x,y);

    window_resized(&win,x,y);

    win.limit = 1000.0 / 60.0;
    win.target = win.limit;

    return win;
}

func close_window(win : Window@)
{
    std::destroy_arr_heap_u32(&global_heap,&win.screen);
    os_destroy_window(&win.os_win);
}

func draw_window(win : Window@, screen: const u32[])
{
    os_draw_window(&win.os_win,screen,cast(u32,win.size.x),cast(u32,win.size.y));
}

// NOTE: these are just general helpers we should still be able to
// mess with this manually if we want, this just makes it simpler
// to get a standard 60 fps limited window
func start_frame(win : Window@)
{
    win.start_timestamp = std::timestamp_ms();

    gfx::process_events(win);
}

func end_frame(win : Window@)
{
    win.end_timestamp = std::timestamp_ms();

    taken := win.end_timestamp - win.start_timestamp;

    sleep := win.target - taken;

    //std::print("fps: {}\n",cast(u32,1000.0 / sleep));

    if(sleep > 0.0)
    {
        std::sleep_ms(cast(u32,sleep));
    }

    // overshot the frame
    else
    {
        win.target = win.limit + sleep;
    }
}


func process_events(win: Window@) bool
{
    return os_process_events(win);
}