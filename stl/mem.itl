namespace std;

func memcpy(dst: byte@, src: const byte@, size: usize)
{
    // Copy as max size first
    usize_dst := cast(usize@,dst);
    usize_src := cast(usize@,src);

    units := size / sizeof_type(usize);
    index: usize = 0;

    while(index != units)
    {
        usize_dst[index] = usize_src[index];
        index += 1;
    }

    // Copy remainder
    dst = cast(byte@,&usize_dst[index]);
    src = cast(byte@,&usize_src[index]);

    index = 0;
    size &= sizeof_type(usize) - 1;

    while(index != size)
    {
        dst[index] = src[index];
        index += 1;        
    }
}

func find_mem(haystack: const byte[], needle: const byte[]) [usize, result]
{
    // Nothing to search for no match!
    if !needle
    {
        return 0, result::err;
    }

    for [@v, i] in haystack 
    {
        remain := haystack.len - i;

        // Not enough room to scan for this
        if remain < needle.len
        {
            return 0, result::err;
        }

        // Memory is equal we have a match
        if mem_equal(v, needle.data, needle.len)
        {
            return i, result::ok;
        }
    }

    return 0, result::err;
}


func mem_equal(v1: const byte@, v2: const byte@, size: usize) bool
{
    // Cmp as usize first
    units := size / sizeof_type(usize);
    usize_v1 := cast(const usize@,v1);
    usize_v2 := cast(const usize@,v2);

    for _i in 0 < units
    {
        if(@usize_v1 != @usize_v2)
        {
            return false;
        }

        usize_v1 += 1;
        usize_v2 += 1;
    }

    // Compare remainder
    v1 = cast(byte@,usize_v1);
    v2 = cast(byte@,usize_v2);
    size &= sizeof_type(usize) - 1;
    
    for _i in 0 < size
    {
        if(@v1 != @v2)
        {
            return false;
        }

        v1 += 1;
        v2 += 1;
    }

    return true;   
}

func array_equal(v1: const byte[], v2: const byte[]) bool
{
    if v1.len != v2.len
    {
        return false;
    }

    return mem_equal(v1.data,v2.data,v1.len);
}

func zero_mem(dst: byte@, size : usize)
{
    // Copy max size
    usize_dst := cast(usize@,dst);
    units := size / sizeof_type(usize);
    usize_end := &usize_dst[units];

    while(usize_dst != usize_end)
    {
        @usize_dst = 0;
        usize_dst += 1;
    }

    // Copy remainder
    dst = cast(byte@,usize_dst);
    end := &dst[(size & (sizeof_type(usize) - 1))];
    
    while(dst != end)
    {
        @dst = 0;
        dst += 1;
    }  
}


// TODO: we need to expose an intrin?
/*
    #if INTRIN_BSWAP
    {
        return intrin_bswap(v);
    }
*/

func bswap_u16(v: u16) u16
{
    return (v >> 8) | ((v & 0xff) << 8);
}

func host_to_network_u16(v : u16) u16
{
    // if we are on little endian we need to do a byteswap
    if(LITTLE_ENDIAN)
    {
        return bswap_u16(v);
    }

    // we allready have variables in a native order!
    return v;
}

func swap_mem(v1: byte@, v2: byte@, size: usize)
{
    // TODO: optimize with 64 bit swaps
    for i in 0 < size
    {
        tmp := v1[i];
        v1[i] = v2[i];
        v2[i] = tmp;
    }
}