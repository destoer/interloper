// string type alias
type_alias string = c8[];


constant RUNTIME_SIZE : u32 = 0xfffffff0;

enum itl_type
{
    u8_t,
    u16_t,
    u32_t,
    u64_t,

    s8_t,
    s16_t,
    s32_t,
    s64_t,

    c8_t,

    byte_t,

    bool_t,

    null_t,

    pointer_t,
    array_t,
    struct_t,
    enum_t,
}

// NOTE: these structs are directly interfaced with by the compiler
// editing cause rtti to fail to compile

struct Type
{
    type_idx : const itl_type;

    // specifiers
    is_const : const bool;
}

struct PointerType (type : const Type)
{
    contained_type : const Type@;
}

struct ArrayType (type : const Type)
{
    contained_type : const Type@;

    // RUNTIME_SIZE or current size!
    size : const u32;

    // size of indexing array
    sub_size : const u32;
}

struct StructType (type : const Type)
{
    struct_idx : const u32;
}

struct EnumType (type : const Type)
{
    enum_idx : const u32;
}


struct Any
{
    // NOTE: for types < GPR_SIZE they are written directly into the pointer
    // use the helper functions to get at the data
    data : const byte@;

    type : const Type@;
}

// struct for generic vla
struct Vla
{
    data : const byte@;
    len : u64;
}

func is_builtin(type_idx : itl_type) bool
{
    return cast(u32,type_idx) < cast(u32,itl_type::pointer_t);
}


func is_builtin_type(type : const Type@) bool
{
    return is_builtin(type.type_idx);
}


func deref_pointer(type: const Type@) const Type@
{
    pointer_type := cast(const PointerType@,type);

    return pointer_type.contained_type;
}

func is_runtime_size(size : u32) bool
{
    return size == RUNTIME_SIZE;
}

func is_pointer(type : const Type@) bool
{
    return type.type_idx == itl_type::pointer_t;
}

// TODO: we want to solve this with java style enums for type info but for now this is good enough
func is_signed(type : const Type@) bool
{
    idx := cast(u32,type.type_idx);

    return idx >= cast(u32,itl_type::s8_t) && idx <= cast(u32,itl_type::s64_t); 
}

func is_array(type : const Type@) bool
{
    return type.type_idx == itl_type::array_t;
}

func int_from_any(any : const Any) u64
{
    return cast(u64,any.data);
}

func bool_from_any(any : const Any) bool
{
    v := int_from_any(any);

    return v == 1;
}

func char_from_any(any : const Any) c8
{
    v := int_from_any(any);

    return cast(c8,v);
}