namespace std;

func is_even(v : u64) bool 
{
    return (v & 1) == 0;
}

func abs(v1: s64) u64
{
    if(v1 < 0)
    {
        return cast(u64,-v1);
    }

    return cast(u64,v1);
}

func min_s64(v1 : s64, v2 : s64) s64
{
    if(v1 < v2)
    {
        return v1;
    }

    return v2;
}

func min_u64(v1 : u64, v2 : u64) u64
{
    if(v1 < v2)
    {
        return v1;
    }

    return v2;
}

func min_u32(v1 : u32, v2 : u32) u32
{
    if(v1 < v2)
    {
        return v1;
    }

    return v2;
}

func max_s64(v1 : s64, v2 : s64) s64
{
    if(v1 > v2) 
    {
        return v1;
    }

    return v2;
}

func max_u64(v1 : u64, v2 : u64) u64
{
    if(v1 > v2) 
    {
        return v1;
    }

    return v2;
}

func max_f64(v1: f64, v2: f64) f64
{
    if(v1 > v2)
    {
        return v1;
    }

    return v2;
}

func min_f64(v1: f64, v2: f64) f64
{
    if(v1 < v2)
    {
        return v1;
    }

    return v2;
}

func in_range_u64(v : u64,lo : u64, hi : u64) bool
{
    return v >= lo && v <= hi;
}

func in_range_s64(v : s64,lo : s64, hi : s64) bool
{
    return v >= lo && v <= hi;
}

func clamp_s64(v1: s64, min: s64, max: s64) s64
{
    if(v1 < min) 
    {
        return min;
    }

    else if(v1 > max)
    {
        return max;
    }

    return v1;
}


/*
func log10(v: f64) u64

func pow(double: f64,pow: f64) f64
*/

struct Vec2I
{
    x: s64;
    y: s64;
}

func vec2i_add(v1: const Vec2I, v2: const Vec2I) Vec2I
{
    return Vec2I {v1.x + v2.x,v1.y + v2.y};
}

func vec2i_clamp_zero(v1: const Vec2I@,limit: const Vec2I@) Vec2I
{
    return Vec2I {
        clamp_s64(v1.x,0,limit.x),
        clamp_s64(v1.y,0,limit.y)
    };
}


func print_vec2i(tag: const string,v1: Vec2I)
{
    println("{}: {} : {}",tag,v1.x,v1.y);
}

struct Vec2F
{
    x : f64;
    y : f64;
}


func vec2f_aabb_intersect(p1: Vec2F,s1: Vec2F, p2: Vec2F, s2: Vec2F) bool
{
    return (p1.x < p2.x + s2.x) && (p1.x + s1.x > p2.x)
        && (p1.y < p2.y + s2.y) && (p1.y + s1.y > p2.y);
}

func vec2f_add(v1: const Vec2F@, v2: const Vec2F@) Vec2F
{
    return Vec2F {v1.x + v2.x, v1.y + v2.y};
}


func vec2f_sub(v1: const Vec2F@, v2: const Vec2F@) Vec2F
{
    return Vec2F {v1.x - v2.x, v1.y - v2.y};
}

func vec2f_scale(v1: const Vec2F@, scale: u32) Vec2F
{
    return Vec2F {v1.x * scale, v1.y * scale};
}


func rand_vec2f(x0: s64, x1: s64, y0: s64, y1: s64) Vec2F
{
    return Vec2F {
        std::rand_range_s64(x0,x1),
        std::rand_range_s64(y0,y1)
    };
}

func vec2f_dot(v1: const Vec2F@, v2: const Vec2F@) f64
{
    return (v1.x * v2.x) + (v1.y * v2.y);
}

func fabs(f1: f64) f64
{
    if(f1 < 0.0)
    {
        return -f1;
    }

    return f1;
}

func float_eq(f1: f64, f2: f64) bool
{
    epsilon := 0.001;
    return fabs(f1 - f2) <= epsilon; 
}

func print_vec2f(tag: const string,v1: Vec2F)
{
    println("{}: {} : {}",tag,v1.x,v1.y);
}


func barycentric_tri(tri: const Vec2F[3], point: const Vec2F@) [f64,f64,f64]
{
    // Constant per TRI
    v0 := vec2f_sub(&tri[1],&tri[0]);
    v1 := vec2f_sub(&tri[2],&tri[0]);

    d00 := std::vec2f_dot(&v0,&v0);
    d01 := std::vec2f_dot(&v0,&v1);
    d11 := std::vec2f_dot(&v1,&v1);
    denom := (d00 * d11) - (d01 * d01);


    // Per point
    v2 := vec2f_sub(point,&tri[0]);
    d20 := vec2f_dot(&v2,&v0);
    d21 := vec2f_dot(&v2,&v1);

    v := ((d11 * d20) - (d01 * d21)) / denom;
    w := ((d00 * d21) - (d01 * d20)) / denom;
    u := 1.0 - v - w;

    return u, v ,w;
}


#attr(no_reorder)
struct Vec3F
{
    x: f64;
    y: f64;
    z: f64;
}


struct Mat4D
{
    mat: f64[4][4];
}


func mul_mat4_vec3(m1: const Mat4D@, m2: const Vec3F@) Vec3F
{
    ans: Vec3F = {?};

    // Implicit w of one on input vec
    ans.x = (m2.x * m1.mat[0][0]) + (m2.y * m1.mat[1][0]) + (m2.z * m1.mat[2][0]) + m1.mat[3][0]; 
    ans.y = (m2.x * m1.mat[0][1]) + (m2.y * m1.mat[1][1]) + (m2.z * m1.mat[2][1]) + m1.mat[3][1]; 
    ans.z = (m2.x * m1.mat[0][2]) + (m2.y * m1.mat[1][2]) + (m2.z * m1.mat[2][2]) + m1.mat[3][2]; 
    w := (m2.x * m1.mat[0][3]) + (m2.y * m1.mat[1][3]) + (m2.z * m1.mat[2][3]) + m1.mat[3][3]; 

    // If w is not 1.0 we have to normalize the cordinates
    if(w != 1.0)
    {
        ans.x /= w;
        ans.y /= w;
        ans.z /= w;
    }

    return ans;
}