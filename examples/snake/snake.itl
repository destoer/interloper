import <graphics>

struct Snake
{
    pos: Vec2D;
    dir: Vec2D;

    speed: s64 = 2; 

    food: Vec2D;
}

func make_snake() Snake
{
    snake: Snake;
    
    return snake;
}


func world_to_screen(pos: Vec2D, size: Vec2D) Vec2D
{
    ans: Vec2D = {?};

    ans.x = (size.x >> 1) + pos.x;
    ans.y = (size.y >> 1) - pos.y;

    return ans;
}

constant BLOCK_SIZE: u32 = 16;

// if block is out of bounds return false
// NOTE: this is not a good way to do clipping but good enough for a basic example
func draw_block(screen: u32[],size: Vec2D, pos: Vec2D, colour: u32) bool
{
    screen_pos := world_to_screen(pos,size);

    if(screen_pos.x < 0 || screen_pos.x + BLOCK_SIZE >= size.x || screen_pos.y < 0 || screen_pos.y + BLOCK_SIZE >= size.y)
    {
        return true;
    }

    dy := size.x;
    cur := (dy * screen_pos.y) + screen_pos.x;

    for(y in 0 < BLOCK_SIZE)
    {
        for(x in 0 < BLOCK_SIZE)
        {
            screen[cur + x] = colour;
        }

        cur += dy;
    }

    return false;
}

func update(snake : Snake@, input: const Input@,screen: u32[], size: Vec2D) bool
{
    // blank the screen
    std::fill_array<u32>(screen,0);

    // update direction
    if(input::is_pressed(input,button_t::up))
    {
        snake.dir = {0,snake.speed};
    }

    else if(input::is_pressed(input,button_t::down))
    {
        snake.dir = {0,-snake.speed};
    }

    else if(input::is_pressed(input,button_t::left))
    {
        snake.dir = {-snake.speed,0};
    }

    else if(input::is_pressed(input,button_t::right))
    {
        snake.dir = {snake.speed,0};
    }

    // update the player pos
    snake.pos = std::vec2_add(snake.pos,snake.dir);

    // update blocks
    if(draw_block(screen,size,snake.pos,0xffff_ffff))
    {
        std::print("Crash! at {} {}\n",snake.pos.x,snake.pos.y);
        return true;
    }

    return false;
}