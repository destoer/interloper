
import <graphics> 
import <colour>

// https://github.com/ssloy/tinyrenderer/wiki/Lesson-1:-Bresenham%E2%80%99s-Line-Drawing-Algorithm

func draw_line(win: gfx::Window@, v1: std::Vec2I@, v2: std::Vec2I@, colour: u32)
{
    v1_clamp := std::vec2i_clamp_zero(v1,&win.bounds);
    v2_clamp := std::vec2i_clamp_zero(v2,&win.bounds);

    y1 := (win.height - v1_clamp.y);
    y2 := (win.height - v2_clamp.y);
    x1 := v1_clamp.x;
    x2 := v2_clamp.x;

    steep := false;

    // Draw more x than y
    if std::abs(x1 - x2) < std::abs(y1 - y2)
    {
        std::swap_s64(&x1,&y1);
        std::swap_s64(&x2,&y2);
        steep = true;
    }

    // x1 should be smallest 
    if x1 > x2 
    {
        std::swap_s64(&x1,&x2);
        std::swap_s64(&y1,&y2);
    }

    stride := win.width;

    y1f := cast(f64,y1);
    y2f := cast(f64,y2);

    for x in x1 < x2 + 1
    {
        t := cast(f64,x - x1) / cast(f64,x2 - x1);
        y := cast(s64,y1f * (1.0 - t) + (y2f * t));

        if steep
        {
            win.screen[(x * stride) + y] = colour;
        }

        else
        {
            win.screen[(y * stride) + x] = colour;
        }
    }
}

func screen_tri_to_device(size: const std::Vec2F@, tri: const std::Vec2F[3], out: std::Vec2F[3])
{
    for [@v, i] in out {
        v.x = (tri[i].x + 0.5) * size.x;
        v.y = (tri[i].y + 0.5) * size.y;
    }
}

func draw_triangle(win: gfx::Window@, tri_screen: std::Vec2F[3], colour: u32)
{
    tri: std::Vec2F[3] = {?};
    screen_tri_to_device(&win.size,tri_screen,tri);

    // Compute the bounding box
    max := std::Vec2I {0,0};
    min := std::Vec2I {win.bounds.x,win.bounds.y};

    for @point in tri
    {
        x := cast(s64,point.x);
        min.x = std::max_s64(0,std::min_s64(min.x,x));
        max.x = std::min_s64(win.bounds.x,std::max_s64(max.x,x));

        y := cast(s64,point.y);
        min.y = std::max_s64(0,std::min_s64(min.y,y));
        max.y = std::min_s64(win.bounds.y,std::max_s64(max.y,y));     
    }

    stride := win.width;
    height := win.height;

    // Compute barycentric cordinate info outside of the loop
    v0 := std::vec2f_sub(&tri[1],&tri[0]);
    v1 := std::vec2f_sub(&tri[2],&tri[0]);

    d00 := std::vec2f_dot(&v0,&v0);
    d01 := std::vec2f_dot(&v0,&v1);
    d11 := std::vec2f_dot(&v1,&v1);
    denom := (d00 * d11) - (d01 * d01);

    for y in min.y < max.y 
    {
        for x in min.x < max.x 
        {
            point := std::Vec2F {cast(f64,x),cast(f64,y)};
            v2 := std::vec2f_sub(&point,&tri[0]);

            d20 := std::vec2f_dot(&v2,&v0);
            d21 := std::vec2f_dot(&v2,&v1);

            v := ((d11 * d20) - (d01 * d21)) / denom;
            w := ((d00 * d21) - (d01 * d20)) / denom;
            u := 1.0 - v - w;

            if(v >= 0.0 && w >= 0.0 && (v + w) <= 1.0)
            {
                colourf := gfx::Colour{u,w,v};
                colour_rgba := gfx::colour_to_rgba(&colourf);

                y_flip := height - y;
                win.screen[(y_flip * stride) + x] = colour_rgba;
            }
        }
    }
}

func draw_line_3f(win: gfx::Window@,v1: const std::Vec3F@, v2: const std::Vec3F@,colour: u32)
{
    NEAR_CLIP := 0.2;

    if(v1.z < NEAR_CLIP || v2.z < NEAR_CLIP)
    {
        return;
    }

    x1 := cast(s64,((v1.x / v1.z) + 0.5) * win.size.x);
    y1 := cast(s64,((v1.y / v1.z) + 0.5) * win.size.y);
    x2 := cast(s64,((v2.x / v2.z) + 0.5) * win.size.x);
    y2 := cast(s64,((v2.y / v2.z) + 0.5) * win.size.y);

    p1 := std::Vec2I {x1,y1};
    p2 := std::Vec2I {x2,y2};

    draw_line(win,&p1,&p2,colour);
}

func render_triangle(win: gfx::Window@)
{
    tri1: std::Vec2F[3] = {{-0.48, -0.35},   {-0.42, -0.17},  {-0.39, -0.33}}; 
    tri2: std::Vec2F[3] = {{-0.22, -0.40},  {-0.27, -0.5},   {-0.39, -0.13}}; 
    tri3: std::Vec2F[3] = {{-0.22, -0.19}, {-0.31, -0.17}, {-0.30, -0.13}}; 

    draw_triangle(win,tri1, RED); 
    draw_triangle(win,tri2, BLUE); 
    draw_triangle(win,tri3, GREEN);
}

func render_cube(win: gfx::Window@)
{
    BASE := -0.25;
    WIDTH := 0.5;
    DIST := 1.0;

    cube: std::Vec3F[8] = 
    {
        {BASE,BASE,DIST},  // A
        {BASE + WIDTH,BASE,DIST}, // B
        {BASE,BASE+WIDTH,DIST}, // C
        {BASE + WIDTH,BASE+WIDTH,DIST}, // D

        {BASE,BASE,DIST + WIDTH}, // E
        {BASE + WIDTH,BASE,DIST + WIDTH}, // F
        {BASE,BASE+WIDTH,DIST + WIDTH}, // G
        {BASE + WIDTH,BASE+WIDTH,DIST+WIDTH}, // H
    };

    colour := RED;

    // Points should probably be translated before we issue draws.
    // But lets worry about speed later
    draw_line_3f(win,&cube[0],&cube[1],colour); // AB
    draw_line_3f(win,&cube[0],&cube[2],colour); // AC
    draw_line_3f(win,&cube[1],&cube[3],colour); // BD
    draw_line_3f(win,&cube[2],&cube[3],colour); // CD

    draw_line_3f(win,&cube[1],&cube[5],colour); // BF
    draw_line_3f(win,&cube[3],&cube[7],colour); // DH
    draw_line_3f(win,&cube[5],&cube[7],colour); // FH
    draw_line_3f(win,&cube[0],&cube[4],colour); // AE

    draw_line_3f(win,&cube[2],&cube[6],colour); // CG
    draw_line_3f(win,&cube[6],&cube[7],colour); // GH
    draw_line_3f(win,&cube[4],&cube[5],colour); // EF
    draw_line_3f(win,&cube[4],&cube[6],colour); // EG
}

func render(win: gfx::Window@)
{
    gfx::blank_screen(win.screen);

    // render_triangle(win);
    render_cube(win);
}

func main() s32
{
    SCREEN_X := 640;
    SCREEN_Y := 480;

    [win, res] := gfx::open_window("interloper",SCREEN_X,SCREEN_Y);

    if(res != gfx::win_result::ok)
    {
        return -1;
    }

    while(!win.quit)
    {
        if(gfx::start_frame(&win) == gfx::win_result::err)
        {
            log::error("Render","Failed to start frame");
            return -1;
        }
    
        if(input::is_pressed(&win.input,input::button_t::start))
        {
            win.quit = true;
            log::info("Render","Quitting");
        }

        render(&win);

        if(gfx::draw_window(&win,win.screen) == gfx::win_result::err)
        {
            log::error("Render","Failed to draw window");
            return -1;
        }

        gfx::end_frame(&win);
    }

    if(gfx::close_window(&win) == gfx::win_result::err)
    {
        log::error("Render","Failed to close window");
        return -1;
    }

    return 0;
}