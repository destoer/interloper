
import <graphics> 
import <colour>
import "model"

// https://haqr.eu/tinyrenderer/
// https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/projection-matrix-introduction.html

func in_screen_bounds(win: gfx::Window@, x: s64, y: s64) bool
{
    return cast(u32,x) < cast(u32,win.width) && cast(u32,y) < cast(u32,win.height);
}

func screen_tri_to_device(half_size: const std::Vec2F@, tri: const std::Vec2F[3], out: std::Vec2F[3])
{
    for [@v, i] in out {
        v.x = (tri[i].x + 1.0) * half_size.x;
        v.y = (1.0 - tri[i].y) * half_size.y;
    }
}

func draw_line(win: gfx::Window@, p1: const std::Vec2F@, p2: const std::Vec2F@, colour: u32)
{
    x1 := p1.x;
    y1 := p1.y;

    x2 := p2.x;
    y2 := p2.y;

    // Make sure we render more x than y
    steep := std::fabs(y2 - y1) > std::fabs(x2 - x1);

    if steep
    {
        std::swap_f64(&x1,&y1);
        std::swap_f64(&x2,&y2);
    }

    // x1 should actually be smaller than x2 as we will
    // iterate over it later.
    if x2 < x1 
    {
        std::swap_f64(&x1,&x2);
        std::swap_f64(&y1,&y2);        
    }

    y := y1;
    m := (y2 - y1) / (x2 - x1);

    stride := win.width;
 
    for x in cast(s64,x1) < cast(s64,x2) + 1
    {
        y_index := cast(s64,y);

        if steep 
        {
            if in_screen_bounds(win,y_index,x)
            {
                win.screen[(x * stride) + y_index] = colour;
            }
        }

        else
        {
            if in_screen_bounds(win,x,y_index)
            {
                win.screen[(y_index * stride) + x] = colour;
            }
        }

        y += m;
    }
}

struct ChangeCord
{
    start: f64;
    col: f64;
    row: f64;
}

struct TriChangeCord
{
    v: ChangeCord;
    w: ChangeCord;
    z: ChangeCord;
}

func tri_dda(tri: const std::Vec2F[3], tri_screen: const std::Vec3F[3], min: const std::Vec2F@) TriChangeCord
{
    v0 := std::vec2f_sub(&tri[1],&tri[0]);
    v1 := std::vec2f_sub(&tri[2],&tri[0]);

    d00 := std::vec2f_dot(&v0,&v0);
    d01 := std::vec2f_dot(&v0,&v1);
    d11 := std::vec2f_dot(&v1,&v1);

    
    v2_min := std::vec2f_sub(min,&tri[0]);
    d20_row := std::vec2f_dot(&v2_min,&v0);
    d21_row := std::vec2f_dot(&v2_min,&v1);

    d20_cc := (tri[1].x - tri[0].x);
    d20_rc := (tri[1].y - tri[0].y);

    d21_cc := (tri[2].x - tri[0].x);
    d21_rc := (tri[2].y - tri[0].y);

    inv_denom := 1.0 / ((d00 * d11) - (d01 * d01));

    v_start := ((d11 * d20_row) - (d01 * d21_row)) * inv_denom;
    v_cc := ((d11 * d20_cc) - (d01 * d21_cc)) * inv_denom;
    v_rc := ((d11 * d20_rc) - (d01 * d21_rc)) * inv_denom;

    w_start := ((d00 * d21_row) - (d01 * d20_row)) * inv_denom;
    w_cc := ((d00 * d21_cc) - (d01 * d20_cc)) * inv_denom;
    w_rc := ((d00 * d21_rc) - (d01 * d20_rc)) * inv_denom;

    u_start := 1.0 - v_start - w_start;
    u_cc := -(v_cc + w_cc);
    u_rc := -(v_rc + w_rc);

    z_start := (u_start * tri_screen[0].z) + (v_start * tri_screen[1].z) + (w_start * tri_screen[2].z);
    z_cc := (u_cc * tri_screen[0].z) + (v_cc * tri_screen[1].z) + (w_cc * tri_screen[2].z);
    z_rc := (u_rc * tri_screen[0].z) + (v_rc * tri_screen[1].z) + (w_rc * tri_screen[2].z);

    return TriChangeCord {
        {v_start,v_cc,v_rc},
        {w_start,w_cc,w_rc},
        {z_start,z_cc,z_rc},
    };
}

func draw_triangle(win: gfx::Window@, tri_screen: const std::Vec3F[3], _colour: u32)
{
    // TODO: For now just drop all the z cord 
    tri: std::Vec2F[3] = {
        {tri_screen[0].x,tri_screen[0].y}, 
        {tri_screen[1].x, tri_screen[1].y}, 
        {tri_screen[2].x, tri_screen[2].y}
    };

    screen_tri_to_device(&win.half_size,tri,tri);

    // Compute the bounding box
    max := std::Vec2I {0,0};
    min := std::Vec2I {win.bounds.x,win.bounds.y};

    for @point in tri
    {
        x := cast(s64,point.x);
        min.x = std::max_s64(0,std::min_s64(min.x,x));
        max.x = std::min_s64(win.bounds.x,std::max_s64(max.x,x));

        y := cast(s64,point.y);
        min.y = std::max_s64(0,std::min_s64(min.y,y));
        max.y = std::min_s64(win.bounds.y,std::max_s64(max.y,y));     
    }

    stride := win.width;

    fmin := std::Vec2F {cast(f64,min.x),cast(f64,min.y)};
    change := tri_dda(tri,tri_screen,&fmin);

    for y in min.y <= max.y 
    {
        v := change.v.start;
        w := change.w.start;
        z := change.z.start;

        for x in min.x <= max.x 
        {
            offset := (y * stride) + x;

            if(v >= 0.0 && w >= 0.0 && (v + w) <= 1.0 && win.z_buffer[offset] <= z)
            {
                if(in_screen_bounds(win,x,y))
                {
                    scaled := (z / 2.0) + 0.5;

                    colourz := gfx::Colour{scaled,scaled,scaled};
                    colourz_rgba := gfx::colour_to_rgba(&colourz);

                    win.screen[offset] = colourz_rgba;
                    win.z_buffer[offset] = z;
                }
            }
            
            v += change.v.col;
            w += change.w.col;
            z += change.z.col;
        }

        change.v.start += change.v.row;
        change.w.start += change.w.row;
        change.z.start += change.z.row;
    }
}



func render(win: gfx::Window@, model: const Model@)
{
    gfx::blank_screen(win.screen);

    for tri in model.faces
    {
        draw_triangle(win,tri.points,RED);
    }
}

func main() s32
{
    [model_res,model] := load_model("/home/destoer/diablo3_pose.obj");

    if(model_res == result::err)
    {
        return -1;
    }

    TAG := "Render";

    SCREEN_X := 640;
    SCREEN_Y := 480;

    [win, res] := gfx::open_window("interloper",SCREEN_X,SCREEN_Y);

    if(res != gfx::win_result::ok)
    {
        log::error(TAG,"Could not open window");
        return -1;
    }

    while(!win.quit)
    {
        if(gfx::start_frame(&win) == gfx::win_result::err)
        {
            log::error(TAG,"Failed to start frame");
            return -1;
        }
    
        if(input::is_pressed(&win.input,input::button_t::start))
        {
            win.quit = true;
            log::info(TAG,"Quitting");
        }

        render(&win,&model);

        if(gfx::draw_window(&win,win.screen) == gfx::win_result::err)
        {
            log::error(TAG,"Failed to draw window");
            return -1;
        }

        gfx::end_frame(&win);
    }

    if(gfx::close_window(&win) == gfx::win_result::err)
    {
        log::error(TAG,"Failed to close window");
        return -1;
    }

    return 0;
}