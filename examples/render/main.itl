
import <graphics> 
import <colour>
import "model"

// https://haqr.eu/tinyrenderer/
// https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/projection-matrix-introduction.html

func in_screen_bounds(win: gfx::Window@, x: s64, y: s64) bool
{
    return cast(u32,x) < win.width && cast(u32,y) < win.height;
}

func screen_tri_to_device(size: const std::Vec2F@, tri: const std::Vec2F[3], out: std::Vec2F[3])
{
    for [@v, i] in out {
        v.x = (tri[i].x + 0.5) * size.x;
        v.y = (0.5 - tri[i].y) * size.y;
    }
}

func draw_line(win: gfx::Window@, p1: const std::Vec2F@, p2: const std::Vec2F@, colour: u32)
{
    x1 := p1.x;
    y1 := p1.y;

    x2 := p2.x;
    y2 := p2.y;

    // Make sure we render more x than y
    steep := std::fabs(y2 - y1) > std::fabs(x2 - x1);

    if steep
    {
        std::swap_f64(&x1,&y1);
        std::swap_f64(&x2,&y2);
    }

    // x1 should actually be smaller than x2 as we will
    // iterate over it later.
    if x2 < x1 
    {
        std::swap_f64(&x1,&x2);
        std::swap_f64(&y1,&y2);        
    }

    y := y1;
    m := (y2 - y1) / (x2 - x1);

    stride := win.width;
 
    for x in cast(s64,x1) < cast(s64,x2) + 1
    {
        y_index := cast(s64,y);

        if steep && in_screen_bounds(win,x,y_index) 
        {
            win.screen[(x * stride) + y_index] = colour;
        }

        else if in_screen_bounds(win,y_index,x)
        {
            win.screen[(y_index * stride) + x] = colour;
        }

        y += m;
    }
}

func draw_triangle(win: gfx::Window@, tri_screen: const std::Vec3F[3], colour: u32)
{
    // TODO: For now just drop all the verts 
    tri: std::Vec2F[3] = {{tri_screen[0].x,tri_screen[0].y}, {tri_screen[1].x, tri_screen[1].y}, {tri_screen[2].x, tri_screen[2].y}};

    screen_tri_to_device(&win.size,tri,tri);

    draw_line(win,&tri[0],&tri[1],colour);
    draw_line(win,&tri[0],&tri[2],colour);
    draw_line(win,&tri[1],&tri[2],colour);
}


func render(win: gfx::Window@, model: const Model@)
{
    gfx::blank_screen(win.screen);

    for tri in model.faces
    {
        draw_triangle(win,tri.points,RED);
    }
}

func main() s32
{
    [model_res,model] := load_model("/home/destoer/diablo3_pose.obj");

    if(model_res == result::err)
    {
        return -1;
    }

    TAG := "Render";

    SCREEN_X := 640;
    SCREEN_Y := 480;

    [win, res] := gfx::open_window("interloper",SCREEN_X,SCREEN_Y);

    if(res != gfx::win_result::ok)
    {
        log::error(TAG,"Could not open window");
        return -1;
    }

    while(!win.quit)
    {
        if(gfx::start_frame(&win) == gfx::win_result::err)
        {
            log::error(TAG,"Failed to start frame");
            return -1;
        }
    
        if(input::is_pressed(&win.input,input::button_t::start))
        {
            win.quit = true;
            log::info(TAG,"Quitting");
        }

        render(&win,&model);

        if(gfx::draw_window(&win,win.screen) == gfx::win_result::err)
        {
            log::error(TAG,"Failed to draw window");
            return -1;
        }

        gfx::end_frame(&win);
    }

    if(gfx::close_window(&win) == gfx::win_result::err)
    {
        log::error(TAG,"Failed to close window");
        return -1;
    }

    return 0;
}