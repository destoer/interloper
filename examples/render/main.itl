
import <graphics> 
import <colour>

// https://github.com/ssloy/tinyrenderer/wiki/Lesson-1:-Bresenham%E2%80%99s-Line-Drawing-Algorithm

func draw_line(win: gfx::Window@, v1: std::Vec2I@, v2: std::Vec2I@, colour: u32)
{
    v1_clamp := std::vec2i_clamp_zero(v1,&win.bounds);
    v2_clamp := std::vec2i_clamp_zero(v2,&win.bounds);

    y1 := (win.size.y - v1_clamp.y);
    y2 := (win.size.y - v2_clamp.y);
    x1 := v1_clamp.x;
    x2 := v2_clamp.x;

    steep := false;

    // Draw more x than y
    if std::abs(x1 - x2) < std::abs(y1 - y2)
    {
        std::swap_s64(&x1,&y1);
        std::swap_s64(&x2,&y2);
        steep = true;
    }

    // x1 should be smallest 
    if x1 > x2 
    {
        std::swap_s64(&x1,&x2);
        std::swap_s64(&y1,&y2);
    }

    stride := win.size.x;

    y1f := cast(f64,y1);
    y2f := cast(f64,y2);

    for x in x1 < x2 + 1
    {
        t := cast(f64,x - x1) / cast(f64,x2 - x1);
        y := cast(s64,y1f * (1.0 - t) + (y2f * t));

        if steep
        {
            win.screen[(x * stride) + y] = colour;
        }

        else
        {
            win.screen[(y * stride) + x] = colour;
        }
    }
}

func draw_triangle(win: gfx::Window@, tri: std::Vec2F[3], colour: u32)
{
    // Compute the bounding box
    max := std::Vec2I {0,0};
    min := std::Vec2I {win.bounds.x,win.bounds.y};

    for @point in tri
    {
        x := cast(s64,point.x);
        min.x = std::max_s64(0,std::min_s64(min.x,x));
        max.x = std::min_s64(win.bounds.x,std::max_s64(max.x,x));

        y := cast(s64,point.y);
        min.y = std::max_s64(0,std::min_s64(min.y,y));
        max.y = std::min_s64(win.bounds.y,std::max_s64(max.y,y));     
    }

    stride := win.size.x;

    // Compute barycentric cordinate info outside of the loop
    v0 := std::vec2f_sub(&tri[1],&tri[0]);
    v1 := std::vec2f_sub(&tri[2],&tri[0]);

    d00 := std::vec2f_dot(&v0,&v0);
    d01 := std::vec2f_dot(&v0,&v1);
    d11 := std::vec2f_dot(&v1,&v1);
    denom := (d00 * d11) - (d01 * d01);

    for y in min.y < max.y 
    {
        for x in min.x < max.x 
        {
            point := std::Vec2F {cast(f64,x),cast(f64,y)};
            v2 := std::vec2f_sub(&point,&tri[0]);

            d20 := std::vec2f_dot(&v2,&v0);
            d21 := std::vec2f_dot(&v2,&v1);

            v := ((d11 * d20) - (d01 * d21)) / denom;
            w := ((d00 * d21) - (d01 * d20)) / denom;
            u := 1.0 - v - w;

            if(v >= 0.0 && w >= 0.0 && (v + w) <= 1.0)
            {
                colourf := gfx::Colour{u,w,v};
                colour_rgba := gfx::colour_to_rgba(&colourf);

                y_flip := win.size.y - y;
                win.screen[(y_flip * stride) + x] = colour_rgba;
            }
        }
    }
}

func draw_line_3f(v1: const std::Vec3F@, v2: const std::Vec3F@)
{

}

func render(win: gfx::Window@)
{
    gfx::blank_screen(win.screen);

    // tri1: std::Vec2F[3] = {{10.0, 70.0},   {50.0, 160.0},  {70.0, 80.0}}; 
    // tri2: std::Vec2F[3] = {{180.0, 50.0},  {150.0, 1.0},   {70.0, 180.0}}; 
    // tri3: std::Vec2F[3] = {{180.0, 150.0}, {120.0, 160.0}, {130.0, 180.0}}; 

    // draw_triangle(win,tri1, RED); 
    // draw_triangle(win,tri2, BLUE); 
    // draw_triangle(win,tri3, GREEN);

    BASE := 200.0;
    WIDTH := 40.0;
    DIST := 30.0;

    cube: std::Vec3F[8] = 
    {
        {BASE,BASE,DIST},  // A
        {BASE + WIDTH,BASE,DIST}, // B
        {BASE,BASE+WIDTH,DIST}, // C
        {BASE + WIDTH,BASE+WIDTH,DIST}, // D

        {BASE,BASE,DIST + WIDTH}, // E
        {BASE + WIDTH,BASE,DIST + WIDTH}, // F
        {BASE,BASE+WIDTH,DIST + WIDTH}, // G
        {BASE + WIDTH,BASE+WIDTH,DIST+WIDTH}, // H
    };

    // Points should probably be translated before we issue draws.
    // But lets worry about speed later
    draw_line_3f(&cube[0],&cube[1]); // AB
    draw_line_3f(&cube[0],&cube[2]); // AC
    draw_line_3f(&cube[1],&cube[3]); // BD
    draw_line_3f(&cube[2],&cube[3]); // CD

    draw_line_3f(&cube[1],&cube[5]); // BF
    draw_line_3f(&cube[3],&cube[7]); // DH
    draw_line_3f(&cube[5],&cube[7]); // FH
    draw_line_3f(&cube[0],&cube[4]); // AE

    draw_line_3f(&cube[2],&cube[6]); // CG
    draw_line_3f(&cube[6],&cube[7]); // GH
    draw_line_3f(&cube[3],&cube[5]); // EF
    draw_line_3f(&cube[3],&cube[6]); // EG

}

func main() s32
{
    SCREEN_X := 640;
    SCREEN_Y := 480;

    [win, res] := gfx::open_window("interloper",SCREEN_X,SCREEN_Y);

    if(res != gfx::win_result::ok)
    {
        return -1;
    }

    while(!win.quit)
    {
        if(gfx::start_frame(&win) == gfx::win_result::err)
        {
            log::error("Render","Failed to start frame");
            return -1;
        }
    
        if(input::is_pressed(&win.input,input::button_t::start))
        {
            win.quit = true;
            log::info("Render","Quitting");
        }

        render(&win);

        if(gfx::draw_window(&win,win.screen) == gfx::win_result::err)
        {
            log::error("Render","Failed to draw window");
            return -1;
        }

        gfx::end_frame(&win);
    }

    if(gfx::close_window(&win) == gfx::win_result::err)
    {
        log::error("Render","Failed to close window");
        return -1;
    }

    return 0;
}