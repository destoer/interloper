
import <graphics> 
import <colour>

// https://haqr.eu/tinyrenderer/
// https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/projection-matrix-introduction.html

func in_screen_bounds(win: gfx::Window@, x: s64, y: s64) bool
{
    return cast(u32,x) < win.width && cast(u32,y) < win.height;
}

func screen_tri_to_device(size: const std::Vec2F@, tri: const std::Vec2F[3], out: std::Vec2F[3])
{
    for [@v, i] in out {
        v.x = (tri[i].x + 0.5) * size.x;
        v.y = (tri[i].y + 0.5) * size.y;
    }
}

func draw_triangle(win: gfx::Window@, tri_screen: std::Vec2F[3], colour: u32)
{
    tri: std::Vec2F[3] = {?};
    screen_tri_to_device(&win.size,tri_screen,tri);

    // Compute the bounding box
    max := std::Vec2I {0,0};
    min := std::Vec2I {win.bounds.x,win.bounds.y};

    for @point in tri
    {
        x := cast(s64,point.x);
        min.x = std::max_s64(0,std::min_s64(min.x,x));
        max.x = std::min_s64(win.bounds.x,std::max_s64(max.x,x));

        y := cast(s64,point.y);
        min.y = std::max_s64(0,std::min_s64(min.y,y));
        max.y = std::min_s64(win.bounds.y,std::max_s64(max.y,y));     
    }

    stride := win.width;
    height := win.height;

    // Compute barycentric cordinate info outside of the loop
    v0 := std::vec2f_sub(&tri[1],&tri[0]);
    v1 := std::vec2f_sub(&tri[2],&tri[0]);

    d00 := std::vec2f_dot(&v0,&v0);
    d01 := std::vec2f_dot(&v0,&v1);
    d11 := std::vec2f_dot(&v1,&v1);
    denom := (d00 * d11) - (d01 * d01);

    for y in min.y < max.y 
    {
        for x in min.x < max.x 
        {
            y_flip := height - y;

            if(in_screen_bounds(win,y_flip,x))
            {
                point := std::Vec2F {cast(f64,x),cast(f64,y)};
                v2 := std::vec2f_sub(&point,&tri[0]);

                d20 := std::vec2f_dot(&v2,&v0);
                d21 := std::vec2f_dot(&v2,&v1);

                v := ((d11 * d20) - (d01 * d21)) / denom;
                w := ((d00 * d21) - (d01 * d20)) / denom;
                u := 1.0 - v - w;

                if(v >= 0.0 && w >= 0.0 && (v + w) <= 1.0)
                {
                    colourf := gfx::Colour{u,w,v};
                    colour_rgba := gfx::colour_to_rgba(&colourf);

                    win.screen[(y_flip * stride) + x] = colour_rgba;
                }
            }
        }
    }
}


func render_triangle(win: gfx::Window@)
{
    tri1: std::Vec2F[3] = {{-0.48, -0.35},   {-0.42, -0.17},  {-0.39, -0.33}}; 
    tri2: std::Vec2F[3] = {{-0.22, -0.40},  {-0.27, -0.5},   {-0.39, -0.13}}; 
    tri3: std::Vec2F[3] = {{-0.22, -0.19}, {-0.31, -0.17}, {-0.30, -0.13}}; 

    draw_triangle(win,tri1, RED); 
    draw_triangle(win,tri2, BLUE); 
    draw_triangle(win,tri3, GREEN);
}

func render(win: gfx::Window@)
{
    gfx::blank_screen(win.screen);

    render_triangle(win);
}

func main() s32
{
    TAG := "Render";

    SCREEN_X := 640;
    SCREEN_Y := 480;

    [win, res] := gfx::open_window("interloper",SCREEN_X,SCREEN_Y);

    if(res != gfx::win_result::ok)
    {
        log::error(TAG,"Could not open window");
        return -1;
    }

    while(!win.quit)
    {
        if(gfx::start_frame(&win) == gfx::win_result::err)
        {
            log::error(TAG,"Failed to start frame");
            return -1;
        }
    
        if(input::is_pressed(&win.input,input::button_t::start))
        {
            win.quit = true;
            log::info(TAG,"Quitting");
        }

        render(&win);

        if(gfx::draw_window(&win,win.screen) == gfx::win_result::err)
        {
            log::error(TAG,"Failed to draw window");
            return -1;
        }

        gfx::end_frame(&win);
    }

    if(gfx::close_window(&win) == gfx::win_result::err)
    {
        log::error(TAG,"Failed to close window");
        return -1;
    }

    return 0;
}