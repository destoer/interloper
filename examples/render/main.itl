
import <graphics> 
import <colour>
import "model"

// https://haqr.eu/tinyrenderer/
// https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/projection-matrix-introduction.html

func in_screen_bounds(win: gfx::Window@, x: s64, y: s64) bool
{
    return cast(u32,x) < win.width && cast(u32,y) < win.height;
}

func screen_tri_to_device(size: const std::Vec2F@, tri: const std::Vec2F[3], out: std::Vec2F[3])
{
    for [@v, i] in out {
        v.x = (tri[i].x + 0.5) * size.x;
        v.y = (0.5 - tri[i].y) * size.y;
    }
}

func draw_line(win: gfx::Window@, p1: const std::Vec2F@, p2: const std::Vec2F@, colour: u32)
{
    x1 := p1.x;
    y1 := p1.y;

    x2 := p2.x;
    y2 := p2.y;

    // Make sure we render more x than y
    steep := std::fabs(y2 - y1) > std::fabs(x2 - x1);

    if steep
    {
        std::swap_f64(&x1,&y1);
        std::swap_f64(&x2,&y2);
    }

    // x1 should actually be smaller than x2 as we will
    // iterate over it later.
    if x2 < x1 
    {
        std::swap_f64(&x1,&x2);
        std::swap_f64(&y1,&y2);        
    }

    y := y1;
    m := (y2 - y1) / (x2 - x1);

    stride := win.width;
 
    for x in cast(s64,x1) < cast(s64,x2) + 1
    {
        y_index := cast(s64,y);

        if steep 
        {
            if(in_screen_bounds(win,x,y_index))
            {
                win.screen[(x * stride) + y_index] = colour;
            }
        }

        else
        {
            if(in_screen_bounds(win,y_index,x))
            {
                win.screen[(y_index * stride) + x] = colour;
            }
        }

        y += m;
    }
}

func draw_triangle(win: gfx::Window@, tri_screen: std::Vec2F[3], colour: u32)
{
    tri: std::Vec2F[3] = {?};
    screen_tri_to_device(&win.size,tri_screen,tri);

    draw_line(win,&tri[0],&tri[1],colour);
    draw_line(win,&tri[0],&tri[2],colour);
    draw_line(win,&tri[1],&tri[2],colour);
}


func render_triangle(win: gfx::Window@)
{
    tri1: std::Vec2F[3] = {{-0.48, -0.35},   {-0.42, -0.17},  {-0.39, -0.33}}; 
    tri2: std::Vec2F[3] = {{-0.22, -0.40},  {-0.27, -0.5},   {-0.39, -0.13}}; 
    tri3: std::Vec2F[3] = {{-0.22, -0.19}, {-0.31, -0.17}, {-0.30, -0.13}}; 

    draw_triangle(win,tri1, RED); 
    draw_triangle(win,tri2, BLUE); 
    draw_triangle(win,tri3, GREEN);
}

func render(win: gfx::Window@)
{
    gfx::blank_screen(win.screen);

    render_triangle(win);
}

func main() s32
{
    TAG := "Render";

    SCREEN_X := 640;
    SCREEN_Y := 480;

    [win, res] := gfx::open_window("interloper",SCREEN_X,SCREEN_Y);

    if(res != gfx::win_result::ok)
    {
        log::error(TAG,"Could not open window");
        return -1;
    }

    if(load_model("/home/destoer/diablo3_pose.obj") == result::err)
    {
        return -1;
    }

    while(!win.quit)
    {
        if(gfx::start_frame(&win) == gfx::win_result::err)
        {
            log::error(TAG,"Failed to start frame");
            return -1;
        }
    
        if(input::is_pressed(&win.input,input::button_t::start))
        {
            win.quit = true;
            log::info(TAG,"Quitting");
        }

        render(&win);

        if(gfx::draw_window(&win,win.screen) == gfx::win_result::err)
        {
            log::error(TAG,"Failed to draw window");
            return -1;
        }

        gfx::end_frame(&win);
    }

    if(gfx::close_window(&win) == gfx::win_result::err)
    {
        log::error(TAG,"Failed to close window");
        return -1;
    }

    return 0;
}