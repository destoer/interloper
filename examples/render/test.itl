

func test_vec()
{
    // Test Vec2
    {
        v1: const std::Vec2F = {2.0,1.3};
        v2: const std::Vec2F = {0.5,0.4};

        std::test_vec2f(std::vec2f_add(&v1,&v2), std::Vec2F {2.5,1.7},"vec2f v1 + v2");
        std::test_vec2f(std::vec2f_sub(&v1,&v2), std::Vec2F {1.5,0.9},"vec2f v1 - v2");
        std::test_f64(std::vec2f_dot(&v1,&v2),1.52,"vec2f v1 dot v2");
    }

    // Test Vec3
    {
        v1: const std::Vec3F = {2.0,1.3,0.4};
        ident: std::Mat4D = std::MAT4_IDENT;


        // Ident should do nothing!
        std::test_vec3f(std::mul_vec3_mat4(&v1,&ident),v1,"vec3f v1 * mat4_ident");

        m1: const std::Mat4D = {{
            {1.0,2.0,3.0,4.0},
            {2.0,4.0,4.0,2.0},
            {8.0,6.0,4.0,1.0},
            {0.0,0.0,0.0,1.0}
        }};

        v2: const std::Vec3F = {1.0,2.0,3.0};

        std::test_vec3f(std::mul_vec3_mat4(&v2,&m1),std::Vec3F {18.0,24.0,33.0},"vec3f v2 * m1");
    }
}

func test_mat()
{

}

func test_tri()
{
    tri1: std::Vec2F[3] = {{10.0, 70.0},   {50.0, 160.0},  {70.0, 80.0}}; 
    point := std::Vec2F {25.0, 90.0};

    [u,v,w] := std::barycentric_tri(tri1,&point);

    std::assert_log(std::float_eq(u,0.68) && std::float_eq(v,0.21) && std::float_eq(w,0.11) ,"Barycentric {} {} {}",u,v,w);
}

func main() s32 
{
    test_vec();
    test_tri();

    return 0;
}