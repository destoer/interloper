struct Triangle
{
    verticies: Vec3F[3];
}

struct Model
{
    faces: Triangle[];
}


func scan_verticies(line: const string[]) [result,std::Vec3F]
{
    ans: std::Vec3F = {?};

    [res, ans.x] := std::string_to_double(line[1]);
    if(res == result::err)
    {
        return res, ans;
    }

    [res, ans.y] = std::string_to_double(line[2]);
    if(res == result::err)
    {
        return res, ans;
    }

    [res, ans.z] = std::string_to_double(line[3]);
    if(res == result::err)
    {
        return res, ans;
    }

    return result::ok, ans;
}

func load_model(path: const string) result
{
    buf : c8[256];

    [fp,file_err] := std::open_file(path,std::file_mode::read,std::file_opt::open);

    if(file_err)
    {
        log::error("Could not open model file {}",path);
        return result::err;
    }

    rc := std::file_read_res::success;

    paramters := std::make_array(sizeof_type(string));
    verticies := std::make_array(sizeof_type(std::Vec3F));

    while(rc == std::file_read_res::success)
    {
        [str,rc] := std::read_file_line(&fp,buf);
        
        if str
        {
            std::split_str_in(str," ",&paramters);
            split := cast(string[],std::array_buffer(&paramters));

            if std::str_equal(split[0],"v")
            {
                // TODO: check arg len
                [err, vec] := scan_verticies(split);
                std::push_array(&verticies,&vec);

                if(err == result::err)
                {
                    std::crash_and_burn("Format error in model {}",str);
                    return result::err;
                }
            }

            else if std::str_equal(split[0],"f")
            {
                std::println("{}",str);
            }
        }
    }

    std::destroy_array(&paramters);
    std::destroy_array(&verticies);

    return result::ok;
}